<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>불변함수 TEST</title>
  </head>
  <body>
    <script>
      // 0. React 엔진 - 데이터 변경감지 하여 UI 그려주는 엔진임
      // 1. 실행과정 (index.html) -> SPA(싱글페이지 애플리케이션)
      // react는 html이 바뀌는게 아니라, body의 데이터가 바뀌는 것
      // package의 'start' 실행(react-scripts)
      // start 진행 시 render 함수 실행(그림 그리기) -> index의 <APP/> 실행함
      // public의 index.html의 root라는 아이디 찾은 후 해당 영역에 App의 내용을 그림
      // index.html에 라이브러리 추가해서 사용 가능
      // 결국 열리는 파일은 index.html임
      // 2. JSX 문법
      // 아래의 function 안에 들어가는 문법이 JSX 문법임
      // JS에 html 문법을 넣는게 JSX 문법임
      // 3.바벨(자바스크립트는 ES5 ->ES6) ES5를 ES6로 변환해주는 컴파일러

      // 기본문법
      // 1. 리액트는 하나의 태그만(dom만) 리턴할 수 있다.
      // 2. 변수 선언은 let 혹은 const로만 가능함
      //  let은 변수, const는 상수
      // 3. if 사용 불가능, 3항 연산자 사용 가능(조건 ? 참 : 거짓)
      // 4. 조건부 렌더링(조건 && 값, 참일 경우에만 보여줌. 거짓일 경우에는 출력 안 함)
      // 5. undefined = null
      // 6. css 디자인
      //  - 내부에 적는 방법
      //  - 외부 파일에 적는 방법
      //  - 라이브러리 사용(부트스트랩, componet-styled)
      // let a = 10;
      // const b = 20;

      // function App() {
      //   let c;
      //   console.log("c", c);

      //   // 내부에서 사용하는 css. 추천 안 함
      //   const mystyle = {
      //     color: "red",
      //   };

      //   // className = box-style 은 APP.css 파일에서 설정한 오브젝트를 반영함.
      //   // 내부에서 사용하는 css
      //   return (
      //     <div>
      //       <div style={mystyle}>
      //         삼항연산자 {a === 10 ? "10입니다." : "10이 아닙니다."}
      //       </div>
      //       <h1 className="box-style">조건부 렌더링 {b === 20 && "20입니다."}</h1>
      //       <hr></hr>
      //     </div>
      //   );
      // }

      // react 특성상 component가 변경될 경우 랜더링이 진행됨
      // 자주 랜더링이 진행되면 속도가 느려짐
      // 따라서 최적화를 통해 변경된 부분만 랜더링 진행
      // 불변함수를 이용해서 변경이 필요 없는 부분은 변경하지 않음
      // react 동작 순서는 다음과 같음
      // 1. 변화 감지
      // 2. A 부모(큰 틀) 다시 그려야 하는지 연산
      // 3. 자식도 다시 그려야 하는지 연산
      // 4. 랜더링
      // 불변함수 사용 시 아래와 같이 진행
      // 1. 변화 감지
      // 2. 레퍼런스를 이용해 변화된 부분 확인(부모, 자식) -> 연산 최적화
      // 3. 변화된 곳 랜더링
      // concat, filter, map, slice, 스프레드(전개) 연산자

      console.log("1. ============== 스프레드 연산자");
      const a = [1, 2, 3];
      // const b = a; -> 얕은 복사
      const b = [...a]; // 스프레드 연산자. 깊은 복사. 배열 복사
      b.push(4); // push 는 배열에 값 추가
      console.log(`a의 값은 : ${a}`); // 백틱 사용(키보드 1번 왼쪽), 결과값 : 1,2,3
      console.log(`b의 값은 : ${b}`); // 결과값 : 1,2,3,4

      console.log("2. ============== 추가하기");
      const a2 = [1, 2, 3];
      const b2 = a2.concat(4); // concat은 배열 복사 + 값 추가. concat은 반드시 배열의 마지막에 값이 추가 됨
      console.log(`a2의 값은 : ${a2}`); // 결과값 : 1,2,3
      console.log(`b2의 값은 : ${b2}`); // 결과값 : 1,2,3,4
      const c2 = [0, ...a2, 4]; // 스프레드 연산으로 복사 후 값 추가. 스프레드 연산은 배열의 앞에도 값 추가 가능
      console.log(`c2의 값은 : ${c2}`); // 결과값 : 1,2,3,4

      console.log("3. ============== 걸러내기"); // 삭제할때 사용함
      const a3 = [1, 2, 3];
      const b3 = a3.filter((n) => {
        return n != 1;
      }); // filter는 값을 꺼내서 함수로 던져준다. bool을 return 받는다. true만 걸러낸다.
      console.log(`b3의 값은 : ${b3}`); // 결과값 : 2,3

      console.log("4. ============== 잘라내기");
      const a4 = [1, 2, 3];
      const b4 = a4.slice(0, 2); // 시작부터 몇 개까지 자를 건지 결정함
      console.log(`a4의 값은 : ${a4}`); // 결과값 : 1,2,3
      console.log(`b4의 값은 : ${b4}`); // 결과값 : 1,2
      const c4 = [...a4.slice(0, 2), 4, ...a4.slice(2, 3)]; // 스프레드 연산과 slice를 통해 배열의 값을 변경할 수 있음
      console.log(`c4의 값은 : ${c4}`); // 결과값 : 1,2

      console.log("5. ============== 반복하기");
      const a5 = [1, 2, 3];
      // jsx 문법에서는 foreach 사용함. forEach는 리턴이 안 됨. 따라서 값을 복사할때는 map을 사용함.
      a5.forEach((n) => {
        console.log(n);
      });

      const b5 = a5.map((n) => n + 10); // const b5 = [...a5]; 와 같은 의미
      // map은 반복문으로서 데이터를 가공해서 받을 수 있다.
      // ()=>{} 에서 {}가 없으면 리턴함. {}가 있으면 리턴 안 함.
      console.log(b5);
    </script>
  </body>
</html>
